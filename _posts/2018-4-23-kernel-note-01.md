---
layout: post
title: OS kernel实现日记（一）
key: 20180423
tags:
  - OS
---

一只菜鸡的操作系统学习历程

<!--more-->

## 引言

这个学期有操作系统的专业课，我很早以前已经学过一点皮毛，但几乎所有的教材都对许多细节语焉不详，读之犹如隔靴瘙痒，很不痛快。所以干脆拉了两个同学，试着自己实现一个小型操作系统。虽说找了队友，热心于此的还是只有我一个人，导致最后我疯狂commit了95%以上的代码……以前在知乎上看到有人说一个学得还不错的本科生应该有做出玩具操作系统的能力，当时还觉得这人信口开河，装得过分了，如今自己一试，的确没有当初想象的那么困难。

我把这个小系统称为“TinyOS”，截至到目前为止，TinyOS已经实现了以下特性：

- 分页式内存管理
- 内核线程调度
- 内核进程和用户进程
- 系统调用
- 信号量等基本互斥与同步机制
- 进程消息队列
- 键盘驱动

接下来的计划则是：

- 硬盘驱动和文件系统
- ELF装载器
- 终端

亲手编写操作系统这种在计算机体系中地位崇高的软件，并且只是为了学习和娱乐（写出来又没人用），这是何等浪漫的事情，不写点东西记下此过程中的酸甜苦辣和思考过程就太可惜了，故有此系列文章。

已经过去的开发历程我已经无法详述了，因此本篇所谓的“日记”只包含一些技术上的内容。

### 开发环境和项目构建

TinyOS的开发主要借助于x86虚拟机bochs，我为它编（chao）写（xi）了一个方便的makefile，可以输入`make bochs`直接在构建系统并bochs中运行它。makefile大概流程是：

1. 寻找内核源代码目录下所有的.c文件，调用gcc -MM为每个文件生成依赖文件并包含到makefile中，然后将其编译为一大堆对应的.o。
2. 寻找内核源代码目录下所有的.s文件，调用nasm将其汇编成对应的.bin。
3. 将内核编译出的.o和.bin文件链接为kernel.bootbin，该文件是ELF32格式的。
4. 将boot目录下的mbr.s和bootloader.s分别编译为mbr.bootbin和bootloader.bootbin。这两个输出文件是纯二进制文件，不带任何文件头，也不需要链接。
5. 用dd命令将mbr.s、bootloader.bootbin和kernel.bootbin分别写入磁盘映像文件的指定扇区中。

### 系统启动

x86计算机开机后，首先运行的程序是由硬件厂商编写的BIOS，轮不到我插手。BIOS在完成了基本的初始化和硬件检查后，就检查磁盘的首个扇区，若它的末尾两个字节是预先规定的magic number，BIOS就认为该扇区包含了主引导记录（Main Boot Record，MBR），会将其加载到内存的0x7c00处并跳转到该地址执行。

从MBR开始，这天下就轮到我做主了。然而MBR的容量实在有限（不到一个扇区），这点代码莫说让操作系统大展身手，就是用来加载和初始化操作系统的程序——bootloader都施展不开。因此，MBR要做的事情只有一件，就是将bootloader从磁盘加载到内存中，然后将权利移交给bootloader。

Bootloader是真正开疆拓土的程序，它有一个长长的任务列表：

1. 探测物理内存容量，以后操作系统的内存管理机制会用到
2. 打开A20地址线，解放1M以上的物理内存空间
3. 填充全局描述符表，即进行初始的“分段”
4. 由所处的实模式进入保护模式
5. 启用分页机制，创造第一个虚拟地址空间
6. 装载系统内核，迎接kernel的降临

我不打算在这里陈列无穷多的技术细节，因此只大概阐述每个步骤的做法。

1. BIOS为继任者准备了一些可用的中断例程，其中`0x15`号中断提供了内存探测功能，物理内存容量的探测正是籍由它实现的。

2. 在Intel推出80286时，为了兼容过去的20位地址线（A0~A19），默认将A20以及其上的地址线封锁了，要启用32位地址线，得先设置一个端口中的标志位，这一操作称为“打开A20地址线”。

3. 全局描述符表是由段描述符构成的一个数组，每个段描述符都描述了一种访问内存的“View”，譬如访问范围的开始和结尾、内存是否只读等。TinyOS的bootloader只准备了两个段，分别是覆盖了整个地址空间的代码段和数据段。前者具有可执行属性，用于填充cs段寄存器；后者是可读写的，用于填充ds，gs，ss等一票寄存器。

4. Intel推出80286后，为了兼容之前的16位计算机，将默认进入的16位运行模式称为“实模式”。与之相对的，是更为先进的“保护模式”。要进入保护模式，需要将cr0寄存器中的一个标志位置为1。

5. 要启用分页，需要先填充初始的页目录和页表（x86采用两级页表），而填充的内容决定了进入虚拟地址空间后的内存布局。对此，bootloader将物理内存的0~4MB占用，并给出了以下从虚拟地址到物理地址的转换：

   $$
   \text{0x00000000} \sim \text{0x003fffff} \Rightarrow \text{0x00000000}    \sim \text{0x003fffff} \\
      \text{0xc0000000} \sim \text{0xc03fffff} \Rightarrow \text{0x00000000}    \sim \text{0x003fffff}
   $$
   
   这4MB空间用途如下：
   
   $\text{0x00000000} \sim \text{0x000fffff}$和实模式下的用处相同，为内核代码和显存区域
   
   $\text{0x00100000} \sim \text{0x001fffff}$为内核栈区域，即内核进程所使用的栈（挺奢侈的）
   
   $\text{0x00200000} \sim \text{0x002fffff}$为内核虚拟地址空间的页目录以及前255个页表
   
   $\text{0x00300000} \sim \text{0x003fffff}$为内核保留区域

6. 之前提到，系统内核文件kernel.bootbin是ELF32格式的，因此bootloader需要将其执行视图的各个段装载到虚拟地址空间中正确的位置，并跳转到内核的入口地址处执行。

从进入内核开始，绝大部分的功能就能用C语言编写了。我原本就对x86汇编不熟悉，编写MBR和bootloader时寸步难行，东拼西凑，几乎就要在内核门口放弃了。可是如今看来，种种艰辛却又不足道也，大概受苦都是这样吧。也正因如此，才有人说得出“年轻人就要多吃苦”这样的鬼话来。
