---
layout: post
title: TinyOS实现总结
key: 20180604
tags:
  - OS
---

一只菜鸡的操作系统之旅

<!--more-->

## 引言

我很久以前就从一些像《Modern Operating System》这样的教材中学习过一点操作系统的皮毛，它们大多“居高临下”地陈列各种算法，这么做固然有利于理解原理，但过于high-level的描述让我读之犹如隔靴瘙痒，不够痛快。这个学期有操作系统课程，索性实践实践，亲手编写了一个玩具内核“TinyOS”。

在开始这个项目之前，我甚至没有使用任何Linux发行版的经验，因此TinyOS在设计上和Linux相去甚远，谈不上“类Unix”。也正因如此，TinyOS中有许多外人看来不可理喻的设计，它们是作为一个系统菜鸡的我摸着石头过河留下的痕迹。这篇文章也是批判性的，用来吐槽TinyOS中的种种奇葩设计，也算是我获益良多的证明吧。

时至今日，TinyOS已经支持以下特性：

1. 分页式内存管理
2. 抢占式线程调度
3. 进程资源管理
4. 进程消息队列
5. 信号量和自旋锁
6. 键盘驱动程序
7. 分区管理和文件系统
8. Explorer（用户交互界面）
9. 进程屏幕缓冲区切换
10. 管道

外部文件可以通过专门编写的小工具导入到TinyOS磁盘映像的文件系统中（很不幸，TinyOS并不支持U盘这样的功能，只能通过这种扭曲的方式来和外部交换文件）。我已经为之编写了以下应用程序：

1. 诸如ls，cp，mkdir等命令，它们以elf的形式存放在TinyOS文件系统的特定目录中
2. ed，一个简单的编辑器，能让我在TinyOS下创建和修改文本文件
3. help，能够在在特定目录下搜索指定条目的帮助文档并在屏幕上呈现

运行时截图如下：

![]({{site.url}}/postpics/tiny-os/01-explorer.png){: width="70%"}

![]({{site.url}}/postpics/tiny-os/02-ed.png){: width="70%"}

在未来的一两个月内，我计划为TinyOS添加一个编程语言的解释器（它至少得能够自举），实现我在TinyOS上编写代码并运行的梦想。在自己的操作系统上用自己的语言编写程序，并用自己的编译器/解释器运行，这是何等浪漫的事情啊！

## 模块简介

TinyOS整体结构如下图所示：

TODO

内核各模块的功能如下：

| 模块          | 功能                                                                         |
| ---          | ---                                                                          |
| 内核内存管理   |负责物理内存的分配和释放，虚拟地址空间管理，以及内核专用的内存分配器。                    |
| 进程管理      |负责进程管理和线程调度，许多基本的同步机制（信号量、自旋锁等）也实现于此。                 |
| 中断处理框架   |内核进程可以在此注册中断处理函数。特别地，系统调用是通过0x80号中断实现的。                |
| 进程间消息传递 |实现了“消息源”和“接收者”之间的多对多消息发送机制。                                    |
| 设备驱动（们） |键盘驱动和硬盘驱动                                                                |
| 屏幕输出管理   |管理屏幕输出，每个应用程序都可以有单独的显示缓存，缓存的分配、写入等在此处实现。            |
| 文件系统      |TinyOS原生地支持了多种类型的分区，但目前我只实现了一个基本的AFS文件系统。                 |
| ELF装载      |将elf文件中的各segments装载到正确的内存区域（并不支持动态链接这样的高级特性）。            |
| Explorer    |用户界面，作用和shell大致相当。用户进程启动、管道建立等均在该模块中实现。                  |

代码目录结构如下：

| 目录              | 含义                                           |
| ---              | ---                                            |
| src/applications | 应用程序                                        |
| src/boot         | 启动引导程序                                     |
| src/docs         | 系统内help命令所使用的帮助文档                     |
| src/include      | 头文件                                 |
| src/kernel       | 内核                                           |
| src/lib          | 用于编写应用程序的用户库                           |
| src/shared       | 内核和应用程序都会用到的代码，比如string.h这样的基础库 |
| src/tools        | 用来构建系统磁盘映像的外部工具                      |

## 内核内存管理

### 分段

TinyOS共使用了4个段——内核代码段，内核数据段，用户代码段，用户数据段。其中，内核段覆盖0~4GB，即整个地址空间；用户段则覆盖0~3GB，这是因为最高的1GB是内核专用的。用户进程运行时使用的是用户段，这样一来所有试图对内核地址空间的访问都将被段部件阻截下来，实现了对内核的保护。

### 物理内存管理

TinyOS在启动时占用了少量低地址处的物理内存，其他物理内存均是空闲的。TinyOS以物理页为单位管理物理页的分配情况，该模块需要支持以下操作：

1. 分配一个空闲物理页，即取得一个未使用的页框的物理地址
2. 释放一个使用中的物理页，即允许该物理页在以后再次被分配

对这种固定数量的资源分配问题，最直接的方案大概就是位图了。对每个资源，位图用一个对应的二进制位来记录它是否空闲。假设一开始共有`M`个可用物理页，则位图需包含`M`个二进制位；若以1表示资源空闲、以0表示资源被占用，则每次分配物理页时都需要以遍历的方式在位图中查找为1的位，这可能会相当缓慢。因此，TinyOS采用了多级位图来加速查找位图中的空闲位——对位图中的每32个位，用一个位来记录它们之中是否还有空闲，这样的“二级位”需要`ceil(M/32)`个，以此类推，可以定义出三级位、四级位。TinyOS采用了四级位图来管理物理页框的分配情况。由于每级位图中的一个位对应了上一级位图中的32个位，该多级位图可以被看作一棵32叉树。

TinyOS的物理内存管理模块实现于`src/kernel/memory/phy_mem_man.c`中。

### 虚拟地址空间

我们所直接使用的地址称为虚拟地址，它会先经过段部件的翻译（即加上段基址）得到线性地址。TinyOS中所有段的段基址都是0,因此可以认为虚拟地址就是线性地址。

x86采用二级分页技术，在开启了该机制的情况下，任何（32位）线性地址都可以被划分为三部分——高10位的页表号，中间10位的页号，低12位的页内偏移。在访问一个线性地址时，页部件会用页表号到一个特定的目录中查找页表，然后到该页表中用页号查找页框的物理地址，最后用该页框地址和页内偏移相加，得到最终的物理地址。（这里忽略了TLB，它对分页技术的原理阐述并不重要）

分页技术将物理内存虚拟化了，这一中间层允许我们通过切换正使用的页目录来切换从虚拟地址到物理地址的映射。据此，TinyOS为每个进程都提供了单独的虚拟地址空间。每当一个进程被调度器调度运行时，当前使用的页目录就被设置为该进程独有的页目录。这样一来，每个进程都好像独自拥有一个完整的虚拟地址空间一样，不必担心自己的内存访问和别的进程发生冲突。

分页机制还能用来实现进程间内存共享。TinyOS的虚拟地址空间中，0~3GB是用户进程可以访问的区间，3~4GB则是内核专用的区间。所有用户进程的内核地址空间（3~4GB）都是共享的，这在实现上异常简单——把所有页目录中3~4GB对应的页表项都设置成相同的页表地址即可。

据此，TinyOS的虚拟地址空间管理模块提供以下操作：

1. 创建一个虚拟地址空间，即创建一个新的页目录并填充其共享页表项。
2. 销毁一个虚拟地址空间，即释放该页目录下所有的页表和页占用的物理页框。
3. 设置当前正使用的虚拟地址空间，切换进程时需要该操作。

以上功能实现于`src/kernel/memory/vir_mem_man.c`。

### 内核页分配和释放

TinyOS中所有进程都共享3~4GB的内核地址空间，而许多内核模块都需要在这块空间中临时或长期地分配内存，这意味着不仅物理页框是需要管理的资源，虚拟页也是。TinyOS采用了和物理页框管理模块相同的方案来管理内核地址空间。当某个内核模块要求分配4KB（一个页面的大小）内存时，首先分配一个虚拟页，然后分配一个物理页框，最后把该虚拟页到物理页框的映射写入页表中，即可通过该虚拟页中的虚拟地址来访问对应的物理内存。该模块提供了以下接口：

1. alloc_ker_page，申请一个内核页
2. free_ker_page，释放一个内核页

这两个函数相当于以4KB为单位的`malloc`和`free`，实现在`src/kernel/memory/vir_mem_man.c`中，内核地址空间的位图则实现在`src/kernel/memory/vir_page_man.c`中。

## 进程管理和线程调度

通常我们认为线程是一个CPU的执行流，进程则是线程及其使用的各种系统资源的总和。TinyOS的线程由TCB结构体描述，其中包含了该线程的执行栈地址、各寄存器值等描述一个CPU执行流所必须的信息，特别地，每个TCB都持有一个它所在的进程PCB的指针；进程则用PCB结构体表示，其中包含了描述一个进程使用的系统资源所需的全部信息，如该进程的线程表、进程页目录、进程所打开的文件表等。
