---
title: 一个比较浮点数是否相等的方案
key: t20180910
tags:
  - Mathematics
---

除了高精度算术和引入$\varepsilon$误差项，还有第三种方案。

<!--more-->

## 问题

众所周知，计算机表示非整数数值时采用的浮点数（IEEE-754）的精度是很有限的，因此它们之间的相等性测试就成为了一个非平凡的问题。试想你需要写一个程序，由用户输入`x, y, z`三个小数，然后输出`x + y`和`z`是否相等。一个native的实现可能是这样的：

{% highlight c %}
bool IsXPlusYEqualToZ(double x, double y, double z)
{
    return x + y == z;
}
{% endhighlight %}

很不幸，这份代码完全无法正确工作，因为x、y和z大概率无法精确地表示用户所输入的数据，因此计算时总会有那么一点点误差，这很容易导致本该相等的数据给出不等的结果。比如令`x`为`1e-50`，`y`为`1e200`，那么上述函数返回`true`当且仅当`z`为`1e200`，这显然不符合数学中实数的加法定义。

## 两种常见解决方案

要解决上述问题，最直截了当的方案就是引入高精度算术，即手动记录用户输入的每一位，并模拟它们相加和比较的过程，这一方案可以精确地完成任何有理数间的运算。但是高精度算是实在太慢了——设想我正在编写一个光线追踪渲染器，要是每个小数计算都需要几十甚至上百个指令周期，那要等到猴年马月才能渲染出结果来？因此，高精度算术只在特定的情境下可以使用（比如算钱？），推而广之就不行了。

另一个广为人知的方法是引入一个误差容许项$\varepsilon$，即用表达式$abs(x - y) <= epsilon$替代`x == y`。这一方案在大多数情况下工作良好，但也给程序员带来了新的问题：如何选择$\varepsilon$的值？若是选择过大，那么差异较大的两个数也可能被判定为相等；选择过小，就可能将两个“本该相等”的数判定为不相等。事实上，$\varepsilon$的选择和应用情境以及输入数据的范围高度相关，即使是数值分析的专家往往也无法给出一个紧确的误差范围。在工程实践中，$\varepsilon$往往是通过估计和实验来选择的。在较复杂的情境下，甚至需要根据其他数据的大小来动态地计算$\varepsilon$，比如——没错，软件渲染器。

## 第三种方案


