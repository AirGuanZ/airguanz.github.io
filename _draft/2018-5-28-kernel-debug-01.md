---
title: 记自制OS过程中的一个诡异的bug
key: 20180528
tags:
  - OS
---

这个学期我试着打造自己的玩具OS，debug体验酸爽无比，前两天遇到的一个问题更是诡异，这里记录一下。

<!--more-->

# 背景

这个学期我尝试着编写一个x86上的小OS[TinyOS](https://github.com/TinyOSOrg/TinyOS)，主要借助虚拟机bochs运行。
我之前一直是Windows上Visual Studio的狂信徒，这次为了方便开发该项目才开始使用Linux，因而对Linux下的主流调试器gdb并不熟悉。
在这次的开发过程中，我主要的调试手段是逐条执行汇编语句以及printf大法（这printf还是自己造的轮子，不怎么圆），心疼自己。

这两天，我就被线程管理模块的一个bug狠狠地折腾了一顿。尽管到最后发现只是一个小小的失误造成的问题，但我到现在还是没有完全理解这一失误为何会
造成当初观察到的奇怪现象（或许还藏着更加惊悚的bug呢？），因此在这里记一下，也许以后能解决（逃

我的玩具OS并不具备联网下载或是插U盘这样的功能，而它上面又没有任何语言的编译器/解释器，因此如何把外部的文件“拷贝”到
系统中就成为了一个难题。为此，我设计了一种极其简单的分区格式——import分区（导入分区），其中以flat的方式存放要从外部导入到系统内的文件。
我编写了一个简单的工具，它能把指定的文件以import分区的格式写入到我的玩具系统的磁盘映像中；同时，我在OS内部提供了导入命令，它能从import分区中读取文件
并存放到系统所使用的真正的文件系统[AFS](https://airguanz.github.io/2018/05/15/kernel-design.html#afs)中去。

为了测试从磁盘上的一个elf文件创建一个用户进程的功能，我在Linux上编写了一个简单的程序，并用自己提供的用户库编译后导入了玩具OS中。该用户程序如下：

{% highlight c %}
#include <lib/sys.h>

int main();

void _start()
{
    main();
    exit_thread();
}

int main()
{
    printf("Hello, elf!\n");

    while(1)
        yield_cpu();
    return 0;
}
{% endhighlight %}

其中，`yield_cpu`中包含了一个系统调用，它会主动让出CPU，使自己由执行线程变为就绪线程。

# 现象

我花了很长的时间才找到一个能稳定复现该bug的操作步骤：

1. 运行外部工具，从导入分区中获取elf文件
2. 在系统内部运行导入命令，将elf文件保存到AFS中
3. 用该elf文件创建30个用户进程
4. 退出系统（这会杀死所有进程并保存它们未关闭的文件）
5. 重新启动系统，格式化AFS所在的分区，再次运行导入命令获取elf文件
6. 用该elf文件创建30个用户进程

执行这一系列步骤后，第25个用户进程会产生General Protection (GP)异常。

# 排查

可能导致GP异常的原因有很多，如段访问越界、中断代码段权限不正确等，但这里的elf程序是遵纪守法的好公民，不会主动搞
这种事情。对于该bug，我第一时间想到的可能原因有：

1. 分区表的写回机制有问题。因为第一次使用该系统并不会触发bug，只有关机并重启一次后才能重现；注意到重启后是格式化了AFS分区的，
   因此问题应该不在AFS上。唯一能跨越“重启系统，格式化AFS分区”的操作就只有分区表的写回。
2. 内核层面不当的内存操作导致某些关键数据被写坏了，此后系统的行为完全不可信赖。

基于这一想法，我立刻检查了和分区表写回的一切代码，包括磁盘驱动和所有访问了分区表的模块，但并未发现任何端倪。此时，第二种情况是最为可能的，
即在某个神秘的角落里，
