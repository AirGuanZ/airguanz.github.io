---
title: OS kernel设计概述
key: 20180515
tags:
  - OS
---

一只菜鸡的操作系统之旅

<!--more-->

## 引言

这个学期有操作系统的专业课，我很早以前已经学过一点皮毛，但几乎所有的教材都对许多细节语焉不详，读之犹如隔靴瘙痒，很不痛快。所以干脆拉了两个同学，试着自己实现一个小型操作系统。以前在知乎上看到有人说一个学得还不错的本科生应该有做出玩具操作系统的能力，当时还觉得这人信口开河，装得过分了，如今自己一试，的确没有当初想象的那么困难。

我把这个小系统称为“TinyOS”（似乎撞车了某个知名系统……），到目前为止，TinyOS已经实现了以下特性：

- 分页式内存管理
- 内核线程调度
- 内核进程和用户进程
- 系统调用
- 信号量等基本互斥与同步机制
- 进程消息队列
- 键盘驱动
- 硬盘驱动

我正在为它添加文件系统，之后的计划则是：

- ELF装载器
- 终端

TinyOS的源代码在文件目录结构上可以划分为四个部分：

1. 内核部分，位于`src/include/kernel`和`src/kernel`中。
2. 用户库部分，位于`src/include/lib`和`src/lib`中。用户库并不属于内核，它用于交叉编译在TinyOS上运行的程序。
3. 共享库部分，位于`src/include/shared`和`src/shared`中。这里的“共享”是指内核和用户库都需要的代码。
4. 外部工具部分，位于`src/tools`中。外部工具是在系统外部修改磁盘映像的程序，用来完成分区表初始化等工作。

下面概述各主要模块的设计思路。

## 内存管理

### 物理页管理

TinyOS充分使用了x86提供的二级页表。在系统启动时，TinyOS设置了以下从虚拟地址到物理地址的转换：

```
0x00000000~0x003fffff => 0x00000000~0x003fffff
0xc0000000~0xc03fffff => 0x00000000~0x003fffff
```

这4MB空间用途如下：

`0x00000000~0x000fffff`和实模式下的用处相同，为内核代码和显存区域

`0x00100000~0x001fffff`为内核栈区域，即内核进程所使用的栈（挺奢侈的）

`0x00200000~0x002fffff`为内核虚拟地址空间的页目录以及前255个页表

`0x00300000~0x003fffff`为内核保留区域

除了0~4MB外，其余物理内存均由一个专门的物理内存分配器管理，它提供物理页的分配和释放接口。TinyOS使用位图记录物理页框的使用情况，位图中一个位为1表示对应的物理页是空闲的。设想一开始的空闲页框下标范围为`[B, E)`，则需要`ceil((E-B)/32)`个`uint32_t`位图记录其可用性，这一堆位图称为L3位图。然而，分配页框时线性查找这些位图中的可用位可能会极为低效，因此在L3基础上增加一层位图，对每个L3位图均用一个位来记录其是否还有空闲空间，这一层位图需要`ceil(ceil((E-B)/32)/32)`个`uint32_t`，称为L2位图。以此类推，可以定义出L1位图和L0位图。容易证明，即使可用物理内存达到32位地址线的极限——4GB，也只需要1个`uint32_t`类型的L0位图。多级位图示意图如下：

![]({{site.url}}/postpics/multi-level-bitmap.png){: width="70%"}

可以看到，TinyOS用来管理物理内存的实质上是一棵32叉树。

TinyOS的位图索引是以`uint32_t`为单位进行的，这意味着每一曾查询都需要找到32个位中的某个为1的位（为1表示可用），而线性扫描所有位来完成这件事可能浪费大量时间。一种软件解决方案是二分地在一个`uint32_t`中查找为1的位，硬件解决方案则是使用`bsr/bsf`这样的特殊指令来获得目标位的位置。由于x86上的指令周期在不同的实现上极不稳定，TinyOS暂且采用第二种方案（至少在我的i74700MQ上，这两条指令相当高效），同时保留使用第一种方案的可能。

位图本身占用的空间由0~4MB中的内核保留区域提供。

### 虚拟地址空间

一个页目录代表了一个从虚拟地址到物理地址的映射，因此切换正使用的页目录就切换了虚拟地址空间。自从系统启动时开启了分页机制以来，内核就一直运行在自己的虚拟地址空间中。初始的页表和页目录是这样安排的：

![]({{site.url}}/postpics/init-PDE-PTE.png){: width="90%"}

可以看到，在初始化分页机制时，页目录的高255项就被指向了255个页表，尽管实际映射了物理页的只有首个页表，这么做算是个伏笔。众所周知，32位linux将0~3GB地址空间分配给进程使用，每个进程都独占自己0~3GB的虚拟地址空间；而3GB~4GB空间则被所有进程共享，是内核占用的地址空间。这一共享在x86上的实现方式就是共享页表——3GB~4GB空间对应于页目录的第768~1023项，于是我干脆预先分配了255个页表，以后所有进程页目录的第768~1022项都指向这255个页表，这样就实现了高地址空间的共享。

另一个值得注意的细节是页目录的第1023项指向了它自身而非一个页表。通常，页目录项应该存放页表的物理地址，这里把页目录当作页表来访问是一个小trick，它使得我们不必通过页目录和页表的虚拟地址就能在开启分页的情况下直接访问页目录、页表的内容。设想我希望访问页目录中第`i`项内容，那么可以按如下方式构造一个虚拟地址——

{% highlight c %}
uint32_t make_iPDE_addr(uint32_t i)
{
    ASSERT_S(i < 1024);
    return (0b1111111111 << 22) | (0b1111111111 << 12) | (i << 2);
}
{% endhighlight %}

这里`0b1111111111`使用了GCC的二进制字面量扩展。在x86的二级页表方案下，一个虚拟地址被划分为三部分，其中22~31位为页目录索引项，12~21位为页表索引项，0~11位为页内偏移。据此，将虚拟地址转换为物理地址的伪代码为（假设页表和页表项都存在，不会发生缺页中断）：

{% highlight c %}
uint32_t vir_2_phy(uint32_t v)
{
    // PDE: page directory entry，即页目录
    // PTE: page table entry，即页表
    PTE *pte = pde->entrys[v >> 22];
    return pte->entrys[(v >> 12) & 0b1111111111] + (v & 0xfff);
}
{% endhighlight %}

现在把`make_iPDE_addr(i)`构造出的地址带入`vir_2_phy`中，我们将会发现得到的正是页目录第`i`项的物理地址。类似地，可以用下面的方式得到页目录第`i`项对应的页表中的第`j`项的虚拟地址：

{% highlight c %}
uint32_t make_iPTE_addr(uint32_t i, uint32_t j)
{
    ASSERT_S(i < 1024 && j < 1024);
    return (0b1111111111 << 22) | i | (j << 2);
}
{% endhighlight %}

以后每个进程都有自己的页目录，它们的页目录第1023项也都会指向自身所在页的物理地址。

## 进程和线程

### TCB和PCB

TinyOS中，线程指的是内核调度器的调度单位，是一个CPU的执行流；进程则是一个运行的程序，包含了该程序占有的所有资源以及该程序的全部线程。TinyOS用PCB（Process Control Block）来描述进程资源，用TCB（Thread Control Block，并不是Task Control Block）来描述线程。显然，每个PCB应该维护一个TC表格，而每个TCB应当持有一个PCB指针。

到目前为止，TinyOS的线程调度还仅仅是一个简单的框架，采用公平分时调度策略。在该策略下，调度器维护一个全局的就绪线程队列，不断从队列头部取出TCB调度执行，同时把被取代执行的线程push到队列尾部。之前已经提到过，每个TCB都持有一个PCB指针；当进行线程切换时，只需要检查切换前后TCB持有的PCB是否发生了变化，就能够判断是否发生了进程间的切换、是否需要更换页目录等。

### 线程调度

TinyOS采用四状态线程，状态类型定义如下：

{% highlight c %}
enum thread_state
{
    thread_state_running,
    thread_state_ready,
    thread_state_blocked,
    thread_state_killed
};
{% endhighlight %}

其中，`thread_state_running`在除了调度器正在运行时以外的任意时刻都只由一个线程持有；`thread_state_ready`状态的线程都处在就绪线程队列中；`thread_state_blocked`为阻塞态线程，由各自的阻塞源维护；`thread_state_killed`则是被标记为将要销毁的线程。通常销毁线程时，可以直接将其TCB从各种相应的链表中摘除，然后释放TCB空间即可，但当一个线程调用销毁自己的函数时，就不能直接释放其资源（否则下一次调度时会出错）。这种情况下其状态会被设置为`thread_state_killed`，然后由调度器来完成销毁工作。

调度器实现简单粗暴，大概分为以下几个步骤：

1. 若当前线程并非`killed`状态，入就绪线程队列
2. 从就绪线程队列中出队一个进程，称为目标线程
3. 检查前后线程是否属于不同进程，即是否需要切换虚拟地址空间等进程资源
4. 若当前线程处于`killed`状态，释放其资源
5. 转移至目标线程执行

### 线程调用栈和内核栈

每个线程都有自己的调用栈，而该栈必定会占用进程虚拟地址空间中的一片区域。TinyOS将用户地址空间(0~3GB)中的最后32MB用作进程各线程的栈，每个栈大小为1MB，因此每个进程最多同时拥有32个线程。

x86要求在执行特权级发生转换的时候，使用的栈也要发生转换。譬如，特权级为3的用户级线程发起系统调用会使得特权级变为0，这时CPU会自动把调用栈转换到一个预先设置好的地址。因此，每个线程除了有基本的调用栈外，还需要一个用于高特权级执行的内核栈。TinyOS为每个线程分配一个内核页作为它的内核栈。内核栈比调用栈小得多，但它只在特权级升高时使用，不必担心空间过小。

### 线程创建和自降特权级

线程的创建本身非常简单，只需要准备好调用栈，将调用栈顶部初始化为调度器保存现场的格式，然后放进就绪线程队列即可。这样一来，当调度器遇到该线程时，就会认为它是之前被换下的线程，从调用栈中取出执行信息继续执行。事实上，跟据GCC采用的调用约定，调度器手动保存的现场只包括`ebx, ebp, esi, edi`四个寄存器，因而只需要把调用栈顶端初始化为以下结构即可——

{% highlight c %}
struct thread_init_stack
{
    // 由callee保持的寄存器
    uint32_t ebp, ebx, edi, esi;

    // 函数入口
    uint32_t eip;

    // 占位，因为需要一个返回地址的空间
    uint32_t dummy_addr;

    // 线程入口及参数
    thread_exec_func func;
    void *func_param;
};
{% endhighlight %}

在调度器看来，这里的`ebp, ebx, edi, esi`是之前调度时保存的，而`eip, dummy_addr`等则是发生时钟中断时对中断入口函数的调用保存的。需要声明的是，这一结构依赖于编译器使用的调用约定，并不具有很好的可移植性。TinyOS使用的调度器执行的最后一段代码是：

{% highlight asm linenos %}
    mov eax, [esp + 24]
    mov esp, [eax]

    pop ebp
    pop ebx
    pop edi
    pop esi

    ret
{% endhighlight %}

前两行代码将栈指针设置为下一个要执行的线程的栈指针，然后从栈中恢复以前保存的现场，最后的`ret`指令将执行流转移到上次被换下时的指令处。`struct thread_init_stack`中的`eip, dummy_addr`等成员以及其在内存中的布局正是针对这条`ret`指令设计的。

每当一个用户线程刚刚被创建时，由于创建它的线程是0级，必然会有特权级别降低的过程。然而x86在原则上不提供任何自降特权级的操作（不明所以），因此TinyOS采用了一个“邪道”，即通过伪造一个中断处理函数返回的上下文来让CPU误以为自己是在从中断处理函数返回到用户函数，进而允许特权级的降低。由于中断处理上下文过长（保存现场时将一大堆寄存器值压栈），这里就不放上其结构了。

### 进程和线程的销毁

TinyOS同时提供销毁进程和销毁线程的功能，其实现逻辑如下：

```
function destroy_process(PCB p)
    for each thread t(except current thread) in p
        destroy_thread(t)
    if current_thread is in p.thread_list
        destroy(current_thread)

function destroy_thread(TCB t)
    erase t from t.PCB.thread_list
    if t != current_thread
        if t.PCB.thread_list.is_empty() == true
            release resources(except vir_addr_space) of t.PCB
            L.push_back(t.PCB.vir_addr_space)
        release resources of t
    else
        t.state = thread_state_killed
        thread_scheduler()

function release_vir_addr_space
    while true
        while L.is_empty() == false
            v = L.pop_front()
            release v
        yield_CPU()
```

上面的伪代码中，`destroy_process`是通过销毁其中的全部线程来实现的；`destroy_thread`则会检查被销毁的线程是否是其进程的最后一个线程，若是，则释放进程资源。

值得注意的是，释放进程资源的时候并未立即将进程的虚拟地址空间销毁，而是将其加入一个全据链表`L`，由一个内核进程`release_vir_addr_space`销毁`L`中的元素。这是因为如果被销毁的虚拟地址空间正在被使用，那么将其销毁可能导致严重的错误，故这里用一个专门的进程来负责销毁无用的虚拟地址空间。类似地，销毁线程时若被销毁者正在运行，则将其状态置为`thread_state_killed`，由调度器来完成其销毁工作。

## 消息传递

### 消息队列

进程往往需要获取许多系统事件的相关信息，比如键盘输入。TinyOS为每个进程提供一个消息队列，且允许每个进程中有一个线程阻塞在消息队列上，在有消息到来时被唤醒。

内核消息队列并不是拿来进行大规模数据传输的，因而每条消息能够携带的信息量非常有限，除了类型标志外，只剩下12个字节的参数区域——

{% highlight c %}
#define SYSMSG_PARAM_SIZE 12

struct sysmsg
{
    sysmsg_type type;
    uint8_t params[SYSMSG_PARAM_SIZE];
};
{% endhighlight %}

参数区域的含义由每个类型的消息自行规定。

如果进程不及时处理消息导致消息队列被填满，多出来的新消息会被直接丢弃。如果想容纳比默认消息队列大小更多的消息，每个进程可以专门开辟一个线程，它不断将消息队列中的内容迁移到进程自己准备的、足够大的缓冲区中。这样一来，只要在该线程的两次相邻调度期间消息队列没有被填满（这几乎不可能发生），就一定不会发生消息丢失。

### 消息源和接收者

一个进程并不会天然地接收系统中所有消息源的消息，它必须通过系统调用来注册自己要接收的消息类型。譬如，一个进程要想收到键盘按键消息，就必须向键盘管理器（一个公开的消息源）表述这一意愿。这实质上是把它的PCB加入键盘管理器的一个接收者链表(receiver list)中。TinyOS通过一个共享节点式十字链表维护这一多对多关系，当一个进程被销毁时，其PCB会自动从所有已注册的消息源摘除；当一个消息源被销毁时，也会自动从所有注册了该类型消息的进程的消息源列表中将它删除。

![]({{site.url}}/postpics/sysmsg-cross-list.png){: width="70%"}

为此，TinyOS提供了`sysmsg_receiver_list`和`sysmsg_source_list`两个结构体（`include/kernel/sysmsg/sysmsg_src.h`），前者由消息源持有，后者由每个进程持有。任何一个接收者列表/消息源列表被销毁时，它都会自动地维护所有相关列表的一致性，不会出现某个进程被销毁了之后还留存在别的接收者列表中的情况。

## 文件系统

TinyOS规定将分区表放置于磁盘上的固定位置，启动时从此位置加载分区信息即可。分区表记录了磁盘被划分为多少个区域，每个区域的名字、起始扇区、总扇区数以及类型等。

一个区域的类型可以有以下取值：

1. 不存在，这表明对该区域的任何操作都是非法的
2. 未格式化，这表明该区域存在但未建立任何文件系统
3. 某种具体的文件系统编号，这表明磁盘的该区域上有这种文件系统的数据结构

可以看到，TinyOS支持在不同的分区上使用不同的文件系统。在从磁盘上加载分区表时，系统会跟据每个分区的类型创建其对应的文件系统句柄，以后对该分区的操作均通过将句柄传递给相应文件系统的函数来完成。在这一机制下，TinyOS的分区变得和Windows非常相似，绝对路径由分区名和分区内路径两部分构成。当我们需要跟据一个绝对路径对磁盘上的一个文件寻址时，首先由分区模块将分区名转换为该分区上的文件系统数据的句柄，然后以该句柄和路径的剩余部分为实参，调用对应类型的文件系统函数。

### AFS

AFS是TinyOS支持的首个文件系统类型，借鉴了EXT2文件系统的设计。在这里，“文件系统”由两部分构成：

1. 磁盘上的存储结构，即数据及其元数据是如何存放在外存中的。
2. 文件系统模块，即在系统运行时文件系统这个软件是如何工作的。

下面分别介绍AFS对这两部分的设计。

### 存储结构

AFS直接面对磁盘驱动，而驱动提供给AFS的磁盘模型是一个巨大的数组，数组的基本单元是512字节大小的扇区，可以对一段连续的扇区进行读写操作。因此，在将一个分区格式化为一个崭新的AFS分区时，AFS软件模块面对的是一个扇区区间`[begin, begin + count)`，它将在该区间上存储以下数据结构：

1. `begin`扇区存放整个分区的描述符，描述符中包含了分区在磁盘上的位置、分区内文件入口（类似于inode）的使用情况、分区内块组（这个等会儿说）的使用情况等。当系统启动时，每个AFS分区头部扇区内的这些数据都将被读入内存，其指针就是该AFS分区的句柄。
2. 文件入口数组。AFS中每个文件都有一个入口描述符，该描述符记录了文件在磁盘上的位置、文件大小等。在把一个分区格式化为AFS分区时，会用一定的磁盘空间来存放文件入口描述符数组，以后每创建一个文件都要从该数组中申请一个描述符来使用。数组中未被使用的入口描述符用自由链表的形式串联起来，以方便快速查找空闲入口。
3. 块组（Block Group）。AFS使用“块”作为文件大小的基本单位，每个块包含连续的几个扇区（现在暂时是2个）。文件数据存储区被分为多个块组，每个块组由一个块组头部和一些连续的块构成。块组头部用位图记录了块组在磁盘上的位置、大小、哪些块是可用的、哪些块是已经分配出去的等。如果一个块组中还有可使用的空闲块，就称该块组是空闲的。磁盘上所有空闲的块组头部用链表的形式（在磁盘上）串联起来，以方便快速查找空闲的块组。

## 用户界面

## 杂项

### 系统启动

### 中断和系统调用

### 键盘驱动

### 磁盘驱动
